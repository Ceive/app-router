
- Выборка и Исправление общего контекста Environment
- Не ожиданный запрос / Стабилизация запроса
- ConjunctionRoute: Поиск вложенных маршрутов
- Решение о ссылке на родителя

- Конечный Matching, получение общего стека параметров сопоставления Matching
- ObjectPool для Router

Есть 2 варианта реализации иерархичной маршрутизации

1. Использование связи только к дочерним `> childrens`
Данный вариант привлекателен тем, что 1 маршрут может находится в разных ветках используя особенности ссылок на объекты
Иерархия сможет спроецировать на маршрут особенные родительские параметры, в разных размещениях маршрута разные параметры.
Минусом является то что мы ищем маршрут во вложенностях, что бы проложить к нему родительский путь.
Здесь иерархия может быть реализована только в ConjunctionRoute, а частные маршруты остаются в реализации линейной маршрутизации.
	- Требуется внешний интерфейс который будет производить подстановку родительской цепочки к линейным маршрутам
	- Методы интерфейса Route не используются на прямую (может сбивать с толку)
	
2. Использования двустороннего связывания `parent <> childrens`
В таком случае маршрут привязан только к одному родительскому объекту, 
	- Имеется легкость наследования благодаря наличию ссылки на родителя.
	- Введение ссылки на родителя в линейную модель маршрутизирования. Даже если родителя у них не предполагается.
	- Используются методы Route благодаря цепочке обязанностей спомощью ссылки на родителя
	- Множественное местонахождение маршрута достигается при помощи введения декоратора(который имеет свой parent) или клонирования маршрута







